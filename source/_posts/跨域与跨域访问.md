---
title: 跨域与跨域访问
tags:
  - dev
categories: dev
top: false
copyright: true
date: 2018-01-15 16:31:32
---
前端开发中跨域是一个绕不过的问题，跨域的方法也是千奇百怪。无论是名门正派还是奇技淫巧，这里都整理一下，方便后续的查阅。
<!--more-->
## 先考虑几个问题：
> Q:为什么会有跨域问题
> A:浏览器的同源策略限制，浏览器会拒绝跨域请求。
> **严格来说，浏览器并不是拒绝所有的跨域请求，它拒绝的其实是跨域的读操作。浏览器的同于策略是这样执行的：**
> * 浏览器允许跨域写操作（Cross-origin writes）,如链接，重定向
> * 浏览器允许跨域资源嵌入（Cross-origin embedding）,如img，script标签
> * 浏览器不允许跨域读操作（Cross-origin reads）
> 
> Q:什么情况算跨域
> A:非同源请求，均为跨域。
>
> Q:为什么有跨域需求
> A:工程服务化后，不同职责的服务分散在不同的工程中，这些工程的域名往往是不同的，但是一个需求可能需要对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域。

## 同源策略
同源指两个页面拥有相同的协议（protocol）、端口（port）和主> 机（host），那么这两个页面属于同一个源（origin）

![](http://oankigr4l.bkt.clouddn.com/201805151744_850.png)

**同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。**

## 跨域访问
如何实现跨域呢？
### 通过document.domain跨域

### 通过location.hash跨域

### 通过HTML5的postMessage方法跨域

### 通过jsonp跨域

### 通过CORS跨域

### 通过window.name跨域
> window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。


**参考资料**
[JS中的跨域问题](https://juejin.im/post/5ab218b1518825555c1d8a11)

![](http://oankigr4l.bkt.clouddn.com/wexin.png)