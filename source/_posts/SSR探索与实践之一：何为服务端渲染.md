---
title: SSR探索与实践之一：你需要服务端渲染吗
tags:
  - SSR探索与实践
  - ssr
categories: ssr
top: false
copyright: true
date: 2018-07-28 11:17:31
---
使用一个新技能之前，你需要明白这个技能是什么，能给你带来什么。本文就是在介绍这个技术之前探究一下我们到底需要ssr来做什么。
<!--more-->

前端渲染主要面临的问题有两个 SEO、首屏性能。服务端渲染其实早期的ASP,Java,PHP这类渲染都是使用的后端渲染。这里提到的服务器端渲染，更多是指**同构渲染。**即前端渲染是未来趋势，但前端渲染遇到了首屏性能和SEO的问题。对于同构争议最多.
## 前端渲染
### 优势
* 局部刷新。无需每次都进行完整页面请求
* 懒加载。如在页面初始时只加载可视区域内的数据，滚动后rp加载其它数据，可以通过 react-lazyload 实现
* 富交互。使用 JS 实现各种酷炫效果
* 节约服务器成本。省电省钱，JS 支持 CDN 部署，且部署极其简单，只需要服务器支持静态文件即可
* 天生的关注分离设计。服务器来访问数据库提供接口，JS 只关注数据获取和展现
JS 一次学习，到处使用。可以用来开发 Web、Serve、Mobile、Desktop 类型的应用

### 问题
前端渲染主要面临的问题有两个 SEO、首屏性能。

SEO 很好理解。由于传统的搜索引擎只会从 HTML 中抓取数据，导致前端渲染的页面无法被抓取。前端渲染常使用的 SPA 会把所有 JS 整体打包，无法忽视的问题就是文件太大，导致渲染前等待很长时间。特别是网速差的时候，让用户等待白屏结束并非一个很好的体验。

## 后端渲染
### 优势
* 服务端渲染不需要先下载一堆 js 和 css 后才能看到页面（首屏性能）
* SEO
* 服务端渲染不用关心浏览器（js）兼容性问题（随着浏览器发展，这个优点逐渐消失）
* 对于电量不给力的手机或平板，减少在客户端的电量消耗很重要

以上服务端优势其实只有首屏性能和 SEO 两点比较突出。但现在这两点也慢慢变得微不足道了。React 这类支持同构的框架已经能解决这个问题，尤其是 Next.js 让同构开发变得非常容易。还有静态站点的渲染，但这类应用本身复杂度低，很多前端框架已经能完全囊括。

## 同构是未来吗
同构恰恰就是为了解决前端渲染遇到的问题才产生的。
### 优点
#### 有助于SEO
首先确定你的应用是否都要做 SEO，如果是一个后台应用，那么只要首页做一些静态内容宣导就可以了。如果是内容型的网站，那么可以考虑专门做一些页面给搜索引擎
时到今日，谷歌已经能够可以在爬虫中执行 JS 像浏览器一样理解网页内容，只需要往常一样使用 JS 和 CSS 即可。并且尽量使用新规范，使用 pushstate 来替代以前的 hashstate。不同的搜索引擎的爬虫还不一样，要做一些配置的工作，而且可能要经常关注数据，有波动那么可能就需要更新。第二是该做 sitemap 的还得做。相信未来即使是纯前端渲染的页面，爬虫也能很好的解析。
#### 共用前端代码，节省开发时间
其实同构并没有节省前端的开发量，只是把一部分前端代码拿到服务端执行。而且为了同构还要处处兼容 Node.js 不同的执行环境。有额外成本，这也是后面会具体谈到的。
#### 提高首屏性能
由于 SPA 打包生成的 JS 往往都比较大，会导致页面加载后花费很长的时间来解析，也就造成了白屏问题。服务端渲染可以预先使到数据并渲染成最终 HTML 直接展示，理想情况下能避免白屏问题。在我参考过的一些产品中，很多页面需要获取十几个接口的数据，单是数据获取的时候都会花费数秒钟，这样全部使用同构反而会变慢。

### 问题
#### 性能
把原来放在几百万浏览器端的工作拿过来给你几台服务器做，这还是花挺多计算力的。尤其是涉及到图表类需要大量计算的场景。

个性化的缓存是遇到的另外一个问题。可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。

#### 不容忽视的服务器端和浏览器环境差异
前端代码在编写时并没有过多的考虑后端渲染的情景，因此各种 BOM 对象和 DOM API 都是拿来即用。这从客观层面也增加了同构渲染的难度。我们主要遇到了以下几个问题：
* document 等对象找不到的问题
* DOM 计算报错的问题
* 前端渲染和服务端渲染内容不一致的问题

由于前端代码使用的 window 在 node 环境是不存在的，所以要 mock window，其中最重要的是 cookie，userAgent，location。但是由于每个用户访问时是不一样的 window，那么就意味着你得每次都更新 window。
而服务端由于 js require 的 cache 机制，造成前端代码除了具体渲染部分都只会加载一遍。这时候 window 就得不到更新了。所以要引入一个合适的更新机制，比如把读取改成每次用的时候再读取。

#### 内存溢出
前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出的风险并没有考虑充分。

#### 异步操作
前端可以做非常复杂的请求合并和延迟处理，但为了同构，所有这些请求都在预先拿到结果才会渲染。而往往这些请求是有很多依赖条件的，很难调和。纯 React 的方式会把这些数据以埋点的方式打到页面上，前端不再发请求，但仍然再渲染一遍来比对数据。造成的结果是流程复杂，大规模使用成本高。幸运的是 Next.js 解决了这一些，后面会谈到。

#### simple store（redux）
这个 store 是必须以字符串形式塞到前端，所以复杂类型是无法转义成字符串的，比如function。

总的来说，同构渲染实施难度大，不够优雅，无论在前端还是服务端，都需要额外改造。

## 首屏优化
再回到前端渲染遇到首屏渲染问题，除了同构就没有其它解法了吗？总结以下可以通过以下三步解决
* 分拆打包，可以按照页面对包进行分拆，并在页面切换时加上一些 loading 和 transition 效果。
* 交互优化，首次渲染的问题可以用更好的交互来解决
* 部分同构，如把核心的部分如菜单通过同构的方式优先渲染出来。

## 总结
客户端渲染是未来的主要方向，服务端则会专注于在数据和业务处理上的优势。但由于日趋复杂的软硬件环境和用户体验更高的追求，也不能只拘泥于完全的客户端渲染。

同构渲染看似美好，但以目前的发展程度来看，在大型项目中还不具有足够的应用价值，**但不妨碍部分使用来优化首屏性能**。做同构之前 ，一定要考虑到浏览器和服务器的环境差异，站在更高层面考虑。

**参考资料**
[Here's why Client-side Rendering Won](https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52)
[精读前后端渲染之争](https://github.com/camsong/blog/issues/8)

![](http://oankigr4l.bkt.clouddn.com/wexin.png)