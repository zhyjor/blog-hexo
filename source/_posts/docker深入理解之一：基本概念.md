---
title: docker深入理解之一：基本概念
tags:
  - docker
  - docker深入理解
categories: docker
top: false
copyright: true
date: 2018-10-23 08:58:21
---

Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！无论是应用开发者、运维人员、还是其他信息技术从业人员，都有必要认识和掌握Docker，节约有限的生命。

<!--more-->

## 简介

### 什么是 Docker
Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源。

Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。**由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。**

Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。

> 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。

### 使用docker的好处
作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。
* **更高效的利用系统资源**，容器不需要进行硬件虚拟以及运行完整操作系统的额外开销，系统资源的利用列率更高，一个相同配置的主机，相比传统虚拟机技术，往往可以运行更多数量的应用
* **更快速的启动时间**，docker容器应用直接运行于宿主内核，无需启动完整的操作系统，往往可以做到秒级和毫秒级的启动时间
* **一致的运行环境**，docker的镜像提供了除内核以外完整的运行时环境，确保了应用的运行环境一致
* **持续交付和部署**，使用dockerfile使得镜像构建透明化，方便运维团队在生产环境部署镜像
* **更方便的迁移**，docker确保了应用运行环境的一致性，用户可以轻易将应用迁移到另一个平台上。
* **更轻松的维护和扩展**，docker使用的分层存储以及镜像技术，使得应用的重复部分的复用更加容易。

### 对比传统虚拟机
|特性|容器|虚拟机|
|--|---|---|
|启动|秒级|分钟级|
|硬盘使用|一般为MB|一般为GB|
|性能|接近原生|弱于|
|系统支持量|单机支持上千个容器|几十个|

## 基本概念
Docker 包括三个基本概念：镜像（Image）、容器（Container）、仓库（Repository），理解了这三个概念，就理解了 Docker 的整个生命周期。

### 镜像（Image）
OS分为内核空间和用户空间，对于linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而docker镜像就相当于一个root文件系统。docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、
库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会改变。

#### 分层存储
因为镜像包含操作系统的完整root文件系统，其体积往往是庞大的，因此docker在设计时就使用了Union FS技术，将其设计为分层存储的架构。严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说有多层文件系统联合组成。

构建镜像时，会一层层构建，前一层是后一层的基础。每一层构建完就不会发生变化，后一层上的任何改变只发生在自己这一层。比如删除前一层的文件，仅仅在当前层标记为文件已删除。最终文件运行时虽然不会看见这个文件，但是该文件一直跟随着镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像复用、定制变得更加容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己需要的内容，构建新的镜像。

### 容器（Container）
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但是与直接在宿主执行的进程不同，容器进程运行于自己独立的命名空间内。因此容器可以拥有自己的root文件系统、自己的进程空间、甚至自己的用户ID空间。容器内的进程运行在一个隔离的环境中，使用起来就好像一个独立于宿主的操作系统一样。这种特性使得容器封装的应用比直接运行在宿主机上更安全。

前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

**数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。**因此使用数据卷后，容器删除或者重新运行之后，数据不会丢失。

### 仓库（Repository）
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。

一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。

通常，一个仓库会包含同一软件的不同版本镜像，而标签常用于指定该软件的各个版本。可以通过`<仓库名：标签>`的格式指定这是哪个版本的镜像。如果不给出标签，默认就是latest标签。

仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。

#### 公开服务
Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。

国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。

#### 私有 Docker Registry
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。

开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。

除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。

**参考资料**
[]()

![](http://oankigr4l.bkt.clouddn.com/wexin.png)