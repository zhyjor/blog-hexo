---
title: JavaScript常见问题之七：浮点数运算
tags:
  - JavaScript常见问题
  - js
categories: js
top: false
copyright: true
date: 2018-05-16 15:55:34
---
“0.1 + 0.2 = ?”，这道题如果给小学生，他会立马告诉你答案是 0.3，但是交给一些程序去计算，结果就不是那么简单了。
<!--more-->
事实上，不仅仅是 JS，在其他采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。
## IEEE754浮点数的演算
我们知道，科学计数法中 30000 可以写成 3x104，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。

IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者。举个例子，十进制数 150，使用双精度浮点数表示法，表示如下：
```js
// D 表示十进制，B 表示二进制
150D = 2^8 * 0.10010110B // 后面省略了 46 个 0
```
可以通过短除法计算：
```
 150   余数位
÷    2
---------------
    75     0   
÷    2
---------------
    37     1
÷    2
---------------
    18     1
÷    2
---------------
     9     0
÷    2
---------------
     4     1
÷    2
---------------
     2     0
÷    2
---------------
     1     0
÷    2
---------------
     0     1
```
上面是整数的表示法，最后一个余数为高位值，于是拿到 150 对应的二进制数位 10010110.最后一个余数为高位值，于是拿到 150 对应的二进制数位 10010110，也就等于 2^8 * 0.10010110。

小数的表示法采用的是乘二取整，如 0.1:
```
// (0011) 表示循环
0.1D = 2^-3 * 0.110011(0011)
```
其演算方法如下：
```
 0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)
```
如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 0.000110011(0011)，也就等于 2^-3 0.1100110011(0011)。

## IEEE754 浮点数精度丢失
IEEE754 浮点数表示法的数据格式如下图：
```js
/ 下图采用大端表示，高位在左，低位在右。

sign  exponent         fraction
+---+----------+---------------------+
| 1 |   2~12   |         13~64       |
+---+----------+---------------------+
```
* 从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。符号位：高位第 1 位，如图 sign 部分
* 指数位：高位第 2~12 位，如图 exponent 部分
* 尾数位：剩下的 fraction 部分

那么，我们就可以得到：
```
0.1D 
= 2^-4 * 1.10011(0011)B
= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1
= 2^-4 * 1.10011(0011 repeat 12 times)010B
```

## 0.1 + 0.2
根据上面我们了解到的知识，我们可以很容易算出这些值：
```
0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B
0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B
0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B
```
0.1 + 0.2 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：
```
0.1100110011001100110011001100110011001100110011001101B
+  1.1001100110011001100110011001100110011001100110011010B
------------------------------------------------------------
= 10.0110011001100110011001100110011001100110011001100111B
```
得到的二进制数为：
```
10.0110011001100110011001100110011001100110011001100111B
```
小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：
```
2^-2 * 1.0011001100110011001100110011001100110011001100110100
```
这个值转化成真值，结果为：0.30000000000000004。那么 0.1 + 0.2 = 0.30000000000000004 的推演到这里就结束了。

## 相关验证
毕竟咱们手动计算可能存在笔误，可以通过一个叫做 double-bits 的 npm 进行推演，我写了一个小 demo，感兴趣的可以玩耍下：
```js
const db = require('double-bits');
const pad = require('pad');

// [lo, hi] where lo is a 32 bit integer and hi is a 20 bit integer.
const base2Str = (n) => {
  const f = db.fraction(n);
  const s = db.sign(n) ? '-' : '';
  const e = `2^${db.exponent(n) + 1}`;
  const t = `0.${pad(f[1].toString(2), 20, '0')}${pad(f[0].toString(2), 32, '0')}`;
  return `${s}${e} * ${t}`;
};

console.log(base2Str(0.1).toString(2));
console.log(base2Str(0.2).toString(2));
console.log(base2Str(0.3).toString(2));
console.log(base2Str(1.2).toString(2));

// 上面输出结果为：
2^-3 * 0.11001100110011001100110011001100110011001100110011010
2^-2 * 0.11001100110011001100110011001100110011001100110011010
2^-1 * 0.10011001100110011001111001100110011001100110011001100
2^1 * 0.10011001100110011001111001100110011001100110011001100
```
## 最后
为了按照计算机的思维，IEEE754 的标准来计算 0.1 + 0.2，又重新复习了一遍大学计算机基础的知识，原码、反码、补码，以及除二取余、乘二取整计算法，最后能够推演出来，也算是一个胜利吧~



**参考资料**
[揭秘 0.1 + 0.2 != 0.3](http://www.cnblogs.com/hustskyking/p/ieee754-operation-in-js.html)
[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)

![](http://oankigr4l.bkt.clouddn.com/wexin.png)