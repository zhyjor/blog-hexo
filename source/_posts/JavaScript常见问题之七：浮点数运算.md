---
title: JavaScript常见问题之七：计算精度
tags:
  - JavaScript常见问题
  - js
categories: js
top: false
copyright: true
date: 2018-05-16 15:55:34
---
这是几个老生常谈的问题，但又经常遇到。“0.1 + 0.2 为什么不等于0.3”，“3.55保留一位小数的时候为什么是3.5”，为什么后端给我的一个ID突然不准确了，为什么很大的数字在简单计算时得到的结果不对，JavaScript在处理数字相关问题的时候，还是有坑的。
<!--more-->
我们知道JavaScript采用的是双精确度（64位）的浮点数表示法。浮点数（Floating-point Number）是对实数的一种近似表示，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次幂得到。以这种表示法表示的数值，称为浮点数，利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。
## IEEE754介绍
IEEE754标准是电气和电子工程师协会（IEEE）确定的计算机对浮点数的表示的规范，在一些强类型语言与Java、C++等中，浮点数对应的有double，float类型。
### 浮点数的存储格式
wiki上是这样介绍浮点数
二进制浮点数是以符号数值表示法的格式存储，对于如下图。最高有效位被指定为符号位（sign bit），接下来次高的e个比特是指数部分，最后剩下的f个低有效位的比特，存储有效数（significand）的小数部分（）。
![](https://ws2.sinaimg.cn/large/006tNc79ly1g2ipqtte9qj32800c940w.jpg)
![](https://ws1.sinaimg.cn/large/006tNc79ly1g2ip26osxzj30xc0de75t.jpg)
### 浮点数运算
我们知道，科学计数法中 30000 可以写成 3x10^4, 以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。

IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者。举个例子，十进制数 150，使用双精度浮点数表示法，表示如下：
```js
// D 表示十进制，B 表示二进制
150D = 2^8 * 0.10010110B // 后面省略了 46 个 0
```
可以通过短除法计算：
```
 150   余数位
÷    2
---------------
    75     0   
÷    2
---------------
    37     1
÷    2
---------------
    18     1
÷    2
---------------
     9     0
÷    2
---------------
     4     1
÷    2
---------------
     2     0
÷    2
---------------
     1     0
÷    2
---------------
     0     1
```
上面是整数的表示法，最后一个余数为高位值，于是拿到 150 对应的二进制数位 10010110.最后一个余数为高位值，于是拿到 150 对应的二进制数位 10010110，也就等于 2^8 * 0.10010110。

小数的表示法采用的是乘二取整，如 0.1:
```
// (0011) 表示循环
0.1D = 2^-3 * 0.110011(0011)
```
其演算方法如下：
```
 0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)
```
如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 0.000110011(0011)，也就等于 2^-3 0.1100110011(0011)。

## IEEE754 浮点数精度丢失
IEEE754 浮点数表示法的数据格式如下图：
```js
/ 下图采用大端表示，高位在左，低位在右。

sign  exponent         fraction
+---+----------+---------------------+
| 1 |   2~12   |         13~64       |
+---+----------+---------------------+
```
* 从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。符号位：高位第 1 位，如图 sign 部分
* 指数位：高位第 2~12 位，如图 exponent 部分
* 尾数位：剩下的 fraction 部分

那么，我们就可以得到：
```
0.1D 
= 2^-4 * 1.10011(0011)B
= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1
= 2^-4 * 1.10011(0011 repeat 12 times)010B
```

## 0.1 + 0.2
根据上面我们了解到的知识，我们可以很容易算出这些值：
```
0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B
0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B
0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B
```
0.1 + 0.2 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：
```
0.1100110011001100110011001100110011001100110011001101B
+  1.1001100110011001100110011001100110011001100110011010B
------------------------------------------------------------
= 10.0110011001100110011001100110011001100110011001100111B
```
得到的二进制数为：
```
10.0110011001100110011001100110011001100110011001100111B
```
小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：
```
2^-2 * 1.0011001100110011001100110011001100110011001100110100
```
这个值转化成真值，结果为：0.30000000000000004。那么 0.1 + 0.2 = 0.30000000000000004 的推演到这里就结束了。

## 相关验证
毕竟咱们手动计算可能存在笔误，可以通过一个叫做 double-bits 的 npm 进行推演，我写了一个小 demo，感兴趣的可以玩耍下：
```js
const db = require('double-bits');
const pad = require('pad');

// [lo, hi] where lo is a 32 bit integer and hi is a 20 bit integer.
const base2Str = (n) => {
  const f = db.fraction(n);
  const s = db.sign(n) ? '-' : '';
  const e = `2^${db.exponent(n) + 1}`;
  const t = `0.${pad(f[1].toString(2), 20, '0')}${pad(f[0].toString(2), 32, '0')}`;
  return `${s}${e} * ${t}`;
};

console.log(base2Str(0.1).toString(2));
console.log(base2Str(0.2).toString(2));
console.log(base2Str(0.3).toString(2));
console.log(base2Str(1.2).toString(2));

// 上面输出结果为：
2^-3 * 0.11001100110011001100110011001100110011001100110011010
2^-2 * 0.11001100110011001100110011001100110011001100110011010
2^-1 * 0.10011001100110011001111001100110011001100110011001100
2^1 * 0.10011001100110011001111001100110011001100110011001100
```
## 最后
为了按照计算机的思维，IEEE754 的标准来计算 0.1 + 0.2，又重新复习了一遍大学计算机基础的知识，原码、反码、补码，以及除二取余、乘二取整计算法，最后能够推演出来，也算是一个胜利吧~



**参考资料**
[揭秘 0.1 + 0.2 != 0.3](http://www.cnblogs.com/hustskyking/p/ieee754-operation-in-js.html)
[JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)
[js-calculate](https://github.com/yuhaiyang1/float_calculate)
[该死的IEEE-754浮点数](https://segmentfault.com/a/1190000009084877)

![](http://static.zhyjor.com/wexin.png)